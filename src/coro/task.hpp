#pragma once

/*! \file
 * \brief An asynchronous task coroutine
 */

#include "coro.hpp"
#include "sched_rr.hpp"

#include <optional>

namespace coro {

//! An asynchronous task
/*! It starts lazily, can be awaited, and can await other coroutines The final
 * result is generated by \c co_return. It is possible to generate intermediate
 * results by \c co_yield.
 * \tparam R the result type of the coroutine
 * \tparam Sched the scheduler type used for suspending and resuming
 * \test in file test_task.cpp */
template <class R, scheduler Sched> class task {
    //! A helper class for void return value
    struct empty {};
    //! The type for storing coroutine result
    using result_type =
        std::optional<std::conditional_t<std::is_void_v<R>, empty, R>>;
public:
    struct promise_type;
    //! The coroutine handle type
    using handle_type = log_handle<promise_type>;
    //! The coroutine promise type
    struct promise_type:
        log_promise<promise_type, task, std::suspend_always,
            std::suspend_always, R, std::type_identity, std::type_identity>,
        log_awaitable<promise_type, std::type_identity>,
        log_awaiter<promise_type>
    {
        //! Disable a coroutine without a scheduler as the first parameter.
        promise_type() = delete;
        //! Creates the promise object and associates it with a scheduler.
        /*! \tparam Args the remaining coroutine parameters
         * \param[in] sched the scheduler used by this coroutine */
        template <class ...Args> explicit promise_type(Sched& sched, Args...):
            sched(sched)
        {}
        //! Unregisters the coroutine from the scheduler
        ~promise_type() {
            if (sch_it != typename Sched::iterator{}) 
                sched.erase(sch_it);
        }
        //! Stores the result value from \c co_return
        /*! \tparam T a template parameter used only to make this member
         * function a template, which allows to define it conditionally, only
         * if \a R is not \c void
         * \param[in] expr the value from \c co_return */
        template <std::same_as<R> T = R> requires (!std::is_void_v<T>)
        void return_value_impl(T&& expr) {
                current = std::forward<T>(expr);
        }
        //! Stores the result value and suspends
        /*! \tparam T a template parameter used only to make this member
         * function a template, which allows to define it conditionally, only
         * if \a R is not \c void
         * \param[in] expr the value from \c co_yield
         * \return a request for suspension */
        template <std::same_as<R> T = R> requires (!std::is_void_v<T>)
        std::suspend_always yield_value(T&& expr) {
            current = promise_type::log_promise_type::yield_value(
                                                        std::forward<T>(expr));
            return {};
        }
        //! Suspends always
        /*! \return false */
        bool await_ready_impl() {
            return false;
        }
        //! Schedules another coroutine
        /*! \param[in] hnd a handle to this coroutine
         * \return a handle to a coroutine that will be resumed */
        std::coroutine_handle<void>
        await_suspend_impl(std::coroutine_handle<void> hnd) {
            if (sch_it == typename Sched::iterator{})
                sch_it = sched.insert(hnd);
            return sched.resume(sch_it);
        }
        //! Generates the result value of await_resume().
        /*! \tparam T a template parameter used only to make this member
         * function a template, which allows to define it conditionally, only
         * if \a R is \c void */
        template <std::same_as<R> T = R> requires (!std::is_void_v<T>)
        void await_resume() {
        }
        //! Generates the result value of await_resume().
        /*! \tparam T a template parameter used only to make this member
         * function a template, which allows to define it conditionally, only
         * if \a R is \c void
         * \return the current result */
        template <std::same_as<R> T = R> requires (!std::is_void_v<T>)
        const result_type& await_resume() {
            return current;
        }
        //! The current result value
        result_type current;
        //! The scheduler used by this coroutine
        Sched& sched;
        //! The registration of this coroutine in \ref sched
        typename Sched::iterator sch_it{};
    };
    //! The constructor needed by log_promise::get_return_object()
    /*! It stores the coroutine handle.
     * \param[in] promise the promise object */
    explicit task(promise_type& promise):
        handle(handle_type::from_promise(promise))
    {}
    //! Default copy
    task(const task&) = default;
    //! Default move
    task(task&&) noexcept = default;
    //! Destroys the coroutine
    ~task() {
        handle.destroy();
    }
    //! Default copy
    /*! \return \c *this */
    task& operator=(const task&) = default;
    //! Default move
    /*! \return \c *this */
    task& operator=(task&&) noexcept = default;
    //! Gets the current result value
    /*! \return the current result value, \c std::nullopt before the first
     * result value is created */
    const result_type& operator()() const {
        return handle.promise().current;
    }
private:
    //! The coroutine handle
    handle_type handle;
};

} // namespace coro
