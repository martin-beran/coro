#pragma once

/*! \file
 * \brief An asynchronous task coroutine
 */

#include "coro.hpp"
#include "sched_rr.hpp"

#include <optional>

namespace coro {

//! An asynchronous task
/*! It starts lazily, can be awaited, and can await other coroutines The final
 * result is generated by \c co_return. It is possible to generate intermediate
 * results by \c co_yield.
 * \tparam R the result type of the coroutine
 * \tparam Sched the scheduler type used for suspending and resuming
 * \test in file test_task.cpp */
template <class R, scheduler Sched> class task:
        public log_awaitable<task<R, Sched>&, std::type_identity>,
        public log_awaiter<task<R, Sched>>
{
    //! A helper class for void return value
    struct empty {};
    //! The type for storing coroutine result
    using result_type =
        std::optional<std::conditional_t<std::is_void_v<R>, empty, R>>;
public:
    struct promise_type;
    //! The coroutine handle type
    using handle_type = log_handle<promise_type>;
    //! The coroutine promise type
    struct promise_type:
        log_promise<promise_type, task, std::suspend_always,
            std::suspend_always, R, std::type_identity, std::type_identity>
    {
        //! Disable a coroutine without a scheduler as the first parameter.
        promise_type() = delete;
        //! Creates the promise object and associates it with a scheduler.
        /*! \tparam Args the remaining coroutine parameters
         * \param[in] sched the scheduler used by this coroutine */
        template <class ...Args> explicit promise_type(Sched& sched, Args&&...):
            sched(sched)
        {}
        //! Creates the promise object and associates it with a scheduler.
        /*! This constructor is used if the coroutine is a non-static member
         * function of class \a T
         * \tparam T the class containing this coroutine as a non-static member
         * function
         * \tparam Args the remaining coroutine parameters
         * \param[in] sched the scheduler used by this coroutine */
        template <class T, class ...Args>
        explicit promise_type(T&&, Sched& sched, Args&&...):
            sched(sched)
        {}
        //! Default copy
        promise_type(const promise_type&) = default;
        //! Default move
        promise_type(promise_type&&) noexcept = default;
        //! Unregisters the coroutine from the scheduler
        ~promise_type() {
            if (sch_it != typename Sched::iterator{}) 
                sched.erase(sch_it);
        }
        //! Default copy
        /*! \return \c *this */
        promise_type& operator=(const promise_type&) = default;
        //! Default move
        /*! \return \c *this */
        promise_type& operator=(promise_type&&) noexcept = default;
        //! Stores the result value from \c co_return
        /*! \tparam T a template parameter used only to make this member
         * function a template, which allows to define it conditionally, only
         * if \a R is not \c void
         * \param[in] expr the value from \c co_return */
        template <std::same_as<R> T = R> requires (!std::is_void_v<T>)
        void return_value_impl(T&& expr) {
                current = std::forward<T>(expr);
        }
        //! Stores the result value and suspends
        /*! \tparam T a template parameter used only to make this member
         * function a template, which allows to define it conditionally, only
         * if \a R is not \c void
         * \param[in] expr the value from \c co_yield
         * \return a request for suspension */
        template <std::same_as<R> T = R> requires (!std::is_void_v<T>)
        std::suspend_always yield_value(T&& expr) {
            current = promise_type::log_promise_type::yield_value(
                                                        std::forward<T>(expr));
            return {};
        }
        //! The current result value
        result_type current;
        //! The scheduler used by this coroutine
        Sched& sched;
        //! The registration of this coroutine in \ref sched
        typename Sched::iterator sch_it{};
    };
    //! The constructor needed by log_promise::get_return_object()
    /*! It stores the coroutine handle.
     * \param[in] promise the promise object */
    explicit task(promise_type& promise):
        handle(handle_type::from_promise(promise))
    {}
    //! No copy
    /*! Because all copies would destroy the same coroutine via copied \ref
     * handle. */
    task(const task&) = delete;
    //! Default move
    task(task&&) noexcept = default;
    //! Destroys the coroutine
    ~task() {
        handle.destroy();
    }
    //! No copy
    /*! Because all copies would destroy the same coroutine via copied \ref
     * handle.
     * \return \c *this */
    task& operator=(const task&) = delete;
    //! Default move
    /*! \return \c *this */
    task& operator=(task&&) noexcept = default;
    //! Resumes the coroutine and gets the current result value
    /*! The coroutine is not resumed if it is suspended at the final suspend
     * point.
     * \return the current result value, \c std::nullopt before the first
     * result value is created */
    const result_type& operator()() const {
        if (!handle.done())
            handle.resume();
        return handle.promise().current;
    }
    //! Tests if the coroutine has finished.
    /*! \return \c true if the coroutine is suspended at the final suspend
     * point, \c false otherwise */
    [[nodiscard]] bool done() const noexcept {
        return handle.done();
    }
    //! Suspends always
    /*! \return false */
    bool await_ready_impl() {
        return false;
    }
    //! Schedules another coroutine
    /*! \param[in] hnd a handle to this coroutine
     * \return a handle to a coroutine that will be resumed */
    std::coroutine_handle<void>
    await_suspend_impl(std::coroutine_handle<void> hnd) {
        promise_type& p = handle.promise();
        if (p.sch_it == typename Sched::iterator{})
            p.sch_it = p.sched.insert(hnd);
        return p.sched.resume(p.sch_it);
    }
    //! Generates the result value of await_resume().
    /*! \tparam T a template parameter used only to make this member
     * function a template, which allows to define it conditionally, only
     * if \a R is \c void */
    template <std::same_as<R> T = R> requires (std::is_void_v<T>)
    void await_resume() {
    }
    //! Generates the result value of await_resume().
    /*! \tparam T a template parameter used only to make this member
     * function a template, which allows to define it conditionally, only
     * if \a R is \c void
     * \return the current result */
    template <std::same_as<R> T = R> requires (!std::is_void_v<T>)
    const result_type& await_resume() {
        return handle.promise().current;
    }
private:
    //! The coroutine handle
    handle_type handle;
};

} // namespace coro
